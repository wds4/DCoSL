Default properties for newly declared word types
=====

For each word type, by convention, properties `slug`, `name`, `title`, and `description` will be made available by default but will not necessarily be required. Note that in the first example above, `name` and `title` are present under `widgetData` but are absent from `wordData`.

## relationships between slugs

Frequently, the slugs will have the following relationship, as in the example:

In this example, the slugs are all the same (all "Fido"):

```json
{
  "wordData": {
    "slug": "Fido",
    "name": "Fido",
    "title": "Fido",
    "wordTypes": ["animalData","dogData"],
    "metaData": {
      "nostr": {
        "stewardPubkey": "c51a542e4f93afe6f45e5bef002f7a0efcc0a47460a736654c0bee5402c482fa",
        "uniqueIDs": {
          "slug": "relationshipType_isASubsetOf"
        }
      }
    }
  },
  "animalData": {
    "slug": "Fido",
  },
  "dogData": {
    "slug": "Fido",
  }
}
```

But in this example, `wordData.slug` does not equal `relationshipTypeData.slug`:

```json
{
  "wordData": {
    "slug": "relationshipType_isASubsetOf",
    "name": "relationship type: is a subset of",
    "title": "Relationship Type: Is a Subset Of",
    "wordTypes": ["relationshipType"],
    "metaData": {
      "nostr": {
        "stewardPubkey": "c51a542e4f93afe6f45e5bef002f7a0efcc0a47460a736654c0bee5402c482fa",
        "uniqueIDs": {
          "slug": "relationshipType_isASubsetOf"
        }
      }
    }
  },
  "relationshipTypeData": {
    "slug": "isASubsetOf",
    "name": "is a subset of",
    "title": "Is a Subset Of",
    "description": "One of the principle links in a class thread.",
    "wordFromAllowedWordTypes": ["set", "superset"],
    "wordToAllowedWordTypes": ["set", "superset"],
  }
}
```

The reason for making them distinct is that we need to avoid multiple words using the same `wordData.slug`. (Is this a good example? Necessary in this case to use relationshipType_isASubsetOf rather than just isASubsetOf?)
